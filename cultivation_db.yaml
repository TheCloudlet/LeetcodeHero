# =============================================================================
# LeetCode Hero - Cultivation Progress Database
# =============================================================================
# This database tracks your mastery level and progress on LeetCode problems
# for technical interview preparation, particularly focused on Google-style
# algorithmic challenges.
#
# STATUS DEFINITIONS:
# -------------------
# L1_FORGOT    (忘) - Problem completely forgotten, requires re-learning from scratch
# L2_STRUGGLE  (解) - Can solve but with difficulty, not interview-ready yet
# L3_MASTERED  (定) - Can solve within 20 minutes, bug-free, handling all edge cases
#
# FIELD DESCRIPTIONS:
# -------------------
# id:                  LeetCode problem number
# title:               Official problem title from LeetCode
# link:                Relative path to your solution folder
# leetcode-difficulty: Official difficulty (easy/medium/hard)
# topics:              Algorithm/data structure tags for categorization
# status:              Your current mastery level (L1_FORGOT/L2_STRUGGLE/L3_MASTERED)
# refinement_focus:    Specific areas to improve or key insights to remember
#
# TOPIC TAGS:
# -----------
# Common tags include: hashtable, hashset, array, linked-list, stack, queue,
# binary-search, two-pointer, sliding-window, dp, backtracking, graph, tree,
# sorting, string, math, greedy, neetcode150
#
# ENTRY TEMPLATE:
# ---------------
#  - id:
#    title: ""
#    link: "./"
#    leetcode-difficulty:
#    topics:
#    status:
#    refinement_focus: ""
#
# =============================================================================

problems:
  - id: 1
    title: "Two Sum"
    link: "./problems/001_two_sum/"
    leetcode-difficulty: easy
    topics: [hashtable, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Try to use single pass solution"

  - id: 2
    title: "Add Two Numbers"
    link: "./problems/002_add_two_numbers/"
    leetcode-difficulty: medium
    topics: [linked-list, indirect-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Try 1: Indirect-pointer and sum/carry handling

      Try 2: Sum/carry is correctly handled, but indirect pointer usage is incorrect. The resultHead and indirect-pointer declarations are poorly structured. Also, (*indirect) = new ListNode(val); is unclear. I incorrectly wrote indirect = &(new ListNode());

  - id: 3
    title: "Longest Substring Without Repeating Characters"
    link: "./problems/003_longest_substring_without_repeating_characters/"
    leetcode-difficulty: medium
    topics: [hashtable, sliding-window, string, neetcode150]
    status: L3_MASTERED
    refinement_focus: "通常這種題目 While 的使用是關鍵"

  - id: 5
    title: "Longest Palindromic Substring"
    link: "./problems/005_longest_palindromic_substring/"
    leetcode-difficulty: medium
    topics: [iteration, dp, manachers-algorithm, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Expand, DP, or Manacher's algorithm"

  - id: 6
    title: "Zigzag Conversion"
    link: "./problems/006_zigzag_conversion/"
    leetcode-difficulty: medium
    topics: [vector, string]
    status: L3_MASTERED
    refinement_focus: "Updown traverse and push to vector"

  - id: 7
    title: "Reverse Integer"
    link: "./problems/007_reverse_integer/"
    leetcode-difficulty: medium
    topics: [integer, signed, boundary]
    status: L2_STRUGGLE
    refinement_focus: "The key is boundary + minus"

  - id: 8
    title: "String to Integer"
    link: "./problems/008_string_to_integer/"
    leetcode-difficulty: medium
    topics: [parsing, stoi, boundary, signed, overflow]
    status: L3_MASTERED
    refinement_focus: "boundary + minus"

  - id: 9
    title: "Palindrome Number"
    link: "./problems/009_palindrome_number/"
    leetcode-difficulty: easy
    topics: [iteration]
    status: L3_MASTERED
    refinement_focus: "std::to_string while"

  - id: 11
    title: "Container With Most Water"
    link: "./problems/011_container_with_most_water/"
    leetcode-difficulty: medium
    topics: [two-pointer, array, greedy, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "find the smallest of the two sides, and move the pointer"

  - id: 12
    title: "Integer to Roman"
    link: "./problems/012_integer_to_roman/"
    leetcode-difficulty: medium
    topics: [array]
    status: L2_STRUGGLE
    refinement_focus: "Transform roman to (value, string) pair and decode greedy"

  - id: 13
    title: "Roman to Integer"
    link: "./problems/013_roman_to_integer/"
    leetcode-difficulty: easy
    topics: [array]
    status: L2_STRUGGLE
    refinement_focus: "Need to peek next, to know current is + or -"

  - id: 14
    title: "Longest Common Prefix"
    link: "./problems/014_longest_common_prefix/"
    leetcode-difficulty: easy
    topics: [array]
    status: L3_MASTERED
    refinement_focus: "The clean solution is to take the first string as golden"

  - id: 15
    title: "3 Sum"
    link: "./problems/015_3sum/"
    leetcode-difficulty: medium
    topics: [two-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Dupicates handling is tricky"

  - id: 16
    title: "3 Sum Closest"
    link: "./problems/016_3sum_closest/"
    leetcode-difficulty: medium
    topics: [two-pointer, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "Same as 015_3Sum, but need to track closest value"

  - id: 17
    title: "Letter Combinations of a Phone Number"
    link: "./problems/017_letter_combinations_of_a_phone_number/"
    leetcode-difficulty: medium
    topics: [hashtable, backtracking, string]
    status: L3_MASTERED
    refinement_focus: "Write a good helper pure function"

  - id: 18
    title: "4 Sum"
    link: "./problems/018_4sum/"
    leetcode-difficulty: medium
    topics: [k-sum, two-pointer, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "generalizing k-sum function"

  - id: 19
    title: "Remove Nth Node From End of List"
    link: "./problems/019_remove_nth_node_from_end_of_list/"
    leetcode-difficulty: medium
    topics: [fast-and-slow-pointer, linked-list, indirect-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Indirect-pointer and fast/slow pointer"

  - id: 20
    title: "Valid Parentheses"
    link: "./problems/020_valid_parentheses/"
    leetcode-difficulty: easy
    topics: [stack, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "I know the stack solution, but I cannot execute it fluently and elegantly"

  - id: 21
    title: "Merge Two Sorted Lists"
    link: "./problems/021_merge_two_sorted_lists/"
    leetcode-difficulty: easy
    topics: [linked-list, indirect-pointer, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: Normal dummy node is okay. But I forget indirect-pointer usage. Always use `ListNode *result;` then `ListNode **indirect = &result;`

      Attempt 2: One-shot using indirect pointer. But a little uncertain when doing it in a sprint.

  - id: 22
    title: "Generate Parentheses"
    link: "./problems/022_generate_parentheses/"
    leetcode-difficulty: medium
    topics: [backtracking, string]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the core idea, implement has some flaws.

  - id: 23
    title: "Merge k Sorted Lists"
    link: "./problems/023_merge_k_sorted_lists/"
    leetcode-difficulty: hard
    topics: [linked-list, heap, priority-queue, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Not really hard, but I need to review how to initialize a priority queue and also prevent adding nullptr to the queue. There are also one way to use merge sort to merge k lists.

  - id: 24
    title: "Swap Nodes in Pairs"
    link: "./problems/024_swap_nodes_in_pairs/"
    leetcode-difficulty: medium
    topics: [linked-list, indirect-pointer, recursion]
    status: L2_STRUGGLE
    refinement_focus: "While loop or helper recursion"

  - id: 25
    title: "Reverse Nodes in k-Group"
    link: "./problems/025_reverse_nodes_in_k-group/"
    leetcode-difficulty: hard
    topics: [linked-list, indirect-pointer, recursion, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the solution, but there are some logical errors. The key is to set `prev` to next group start before reversing, and after reversing, link the previous group's tail to `prev`.

  - id: 34
    title: "Find First and Last Position of Element in Sorted Array"
    link: "./problems/034_find_first_and_last_position_of_element_in_sorted_array/"
    leetcode-difficulty: medium
    topics: [binary-search, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "lower_bound and upper_bound"

  - id: 35
    title: "Search Insert Position"
    link: "./problems/035_search_insert_position/"
    leetcode-difficulty: easy
    topics: [binary-search, array, sorting]
    status: L3_MASTERED
    refinement_focus: "lower_bound"

  - id: 36
    title: "Valid Sudoku"
    link: "./problems/036_valid_sudoku/"
    leetcode-difficulty: medium
    topics: [hashset, matrix, simulation, neetcode150]
    status: L3_MASTERED
    refinement_focus: "HashSet"

  - id: 42
    title: "Trapping Rain Water"
    link: "./problems/042_trapping_rain_water/"
    leetcode-difficulty: hard
    topics: [two-pointer, monotonic-stack, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "next-greater-element or two-pointer"

  - id: 48
    title: "Rotate Image"
    link: "./problems/048_rotate_image/"
    leetcode-difficulty: medium
    topics: [matrix]
    status: L3_MASTERED
    refinement_focus: "Transpose + Reverse"

  - id: 49
    title: "Group Anagrams"
    link: "./problems/049_group_anagrams/"
    leetcode-difficulty: medium
    topics: [hashtable, string, sorting, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Sorting"

  - id: 53
    title: "Maximum Subarray"
    link: "./problems/053_maximum_subarray/"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150, kadane-algorithm]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: One shot Kadane's algorithm after praticing LeetCode #152.

  - id: 56
    title: "Merge Intervals"
    link: "./problems/056_merge_intervals/"
    leetcode-difficulty: medium
    topics: [array, sorting, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Sorting + Iterate and Merge"

  - id: 61
    title: "Rotate List"
    link: "./problems/061_rotate_list/"
    leetcode-difficulty: medium
    topics: [linked-list, two-pointer, indirect-pointer]
    status: L3_MASTERED
    refinement_focus: "Make the list circular first. There are optimiazations like if k == length, do nothing"

  - id: 66
    title: "Plus One"
    link: "./problems/066_plus_one/"
    leetcode-difficulty: easy
    topics: [array, math]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: (Pass 15) But the simplest way is to use vector::insert to insert 1 at the beginning if there is a carry at the end.

  - id: 70
    title: "Climbing Stairs"
    link: "./problems/070_climbing_stairs/"
    leetcode-difficulty: easy
    topics: [dp, math, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Fibonacci, bottom-up DP, top-down DP, or even math"

  - id: 76
    title: "Minimum Window Substring"
    link: "./problems/076_minimum_window_substring/"
    leetcode-difficulty: hard
    topics: [hashtable, sliding-window, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Brute for but get TLE. Then use sliding window. I don't know when to use sliding window or brute force. The note is written in the #3719 solution.

  - id: 84
    title: "Largest Rectangle in Histogram"
    link: "./problems/084_largest_rectangle_in_histogram/"
    leetcode-difficulty: hard
    topics: [stack, array, monotonic-stack, neetcode150]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: (Fail 15 + 45) The key is to find the nearest smaller element on both sides for each bar. Use monotonic stack to achieve O(n) time complexity.

  - id: 91
    title: "Decode Ways"
    link: "./problems/091_decode_ways/"
    leetcode-difficulty: medium
    topics: [dp, string, backtracking, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means ways to decode s[0..i-1]. Also, we need to handle 1 digit and 2 digit separately"

  - id: 94
    title: "Binary Tree Inorder Traversal"
    link: "./problems/094_binary_tree_inorder_traversal/"
    leetcode-difficulty: easy
    topics: [tree, dfs]
    status: L2_STRUGGLE
    refinement_focus: "Just finish after #230 so it is a one shot. But I still recomment to practice more."

  - id: 96
    title: "Unique Binary Search Trees"
    link: "./problems/096_unique_binary_search_trees/"
    leetcode-difficulty: medium
    topics: [dp, math, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[n] means number of unique BST that can be built with n nodes. dp[n] = sum of dp[i-1]*dp[n-i] for i in [1..n]. Catalan number"

  - id: 98
    title: "Validate Binary Search Tree"
    link: "./problems/098_validate_binary_search_tree/"
    leetcode-difficulty: medium
    topics: [tree, dfs, binary-tree, neetcode150]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: I only validate all nodes (node->val vs node->left->val) recursively. But actually we need to pass down the valid range (min, max) from root to leaf.

  - id: 100
    title: "Same Tree"
    link: "./problems/100_same_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion"

  - id: 102
    title: "Binary Tree Level Order Traversal"
    link: "./problems/102_binary_tree_level_order_traversal/"
    leetcode-difficulty: medium
    topics: [tree, traversal, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Use nullptr in a queue to mark level end. But I forget to check if the current queue is empty which means we are done. So it causes infinite loop.

  - id: 105
    title: "Construct Binary Tree from Preorder and Inorder Traversal"
    link: "./problems/105_construct_binary_tree_from_preorder_and_inorder_traversal/"
    leetcode-difficulty: medium
    topics: [tree, dfs, recursion, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the idea, but I cannot implement it fluently. The key is to correctly manage the indices of preorder and inorder arrays. Forgot to check if the current subtree is empty (preStart > preEnd || inStart > inEnd)

  - id: 110
    title: "Balanced Binary Tree"
    link: "./problems/110_balanced_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Reviewed the definition of balanced biniary tree. Implementation is smooth, but I forgot to (add 1) when calculating height.

  - id: 104
    title: "Maximum Depth of Binary Tree"
    link: "./problems/104_maximum_depth_of_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Basic DP"

  - id: 124
    title: "Binary Tree Maximum Path Sum"
    link: "./problems/124_binary_tree_maximum_path_sum/"
    leetcode-difficulty: hard
    topics: [tree, dfs, binary-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I have a clear understanding of the code structure, i.e., need a helper function that returns two values as an accumulator. There are two parts that I did not handle correctly. First, if there is only one negative value node, my base case will cause the max path to be 0. So the base case should return INT_MIN. Second, if a node has one negative child path and one positive child path, we need to discard the negative one, i.e., use std::max(0, lPathToLeaf). In sum, this needs more practice.

  - id: 125
    title: "Valid Palindrome"
    link: "./problems/125_valid_palindrome/"
    leetcode-difficulty: easy
    topics: [two-pointer, string, neetcode150]
    status: L3_MASTERED
    refinement_focus: "isalnum() and tolower()"

  - id: 128
    title: "Longest Consecutive Sequence"
    link: "./problems/128_longest_consecutive_sequence/"
    leetcode-difficulty: medium
    topics: [hashset, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "sort is O(n log n), use HashSet to achieve O(n). Check only sequence starters"

  - id: 138
    title: "Copy List with Random Pointer"
    link: "./problems/138_copy_list_with_random_pointer/"
    leetcode-difficulty: medium
    topics: [linked-list, hashtable, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: One-shot with HashMap.

  - id: 139
    title: "Word Break"
    link: "./problems/139_word_break/"
    leetcode-difficulty: medium
    topics: [dp, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Not absolutely sure I can get this right during interview, but I know the idea. ip[i] means s[i..end] can be segmented. Need a helper function isPrefix and a recursive function with memo"

  - id: 141
    title: "Linked List Cycle"
    link: "./problems/141_linked_list_cycle/"
    leetcode-difficulty: easy
    topics: [linked-list, two-pointer, fast-and-slow-pointer, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: I know the fast/slow pointer idea, but I cannot implement it fluently. The key is to check if fast and fast->next are nullptr directly in the while loop condition.

      Attempt 2: One-shot

  - id: 143
    title: "Reorder List"
    link: "./problems/143_reorder_list/"
    leetcode-difficulty: medium
    topics: [linked-list, two-pointer, fast-and-slow-pointer, reverse, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the big picture. But failed at finding the mid node. I used `while (fast && fast->next)` which makes slow point to the second middle node in even-length list. So when merging, the first half is longer than the second half by one node, which causes problem.

  - id: 144
    title: "Binary Tree Preorder Traversal"
    link: "./problems/144_binary_tree_preorder_traversal/"
    leetcode-difficulty: easy
    topics: [tree, dfs]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Easier than inorder or Postorder iterative solution. But I still have problems with the structure of while loop. I need to practice more.

  - id: 145
    title: "Binary Tree Postorder Traversal"
    link: "./problems/145_binary_tree_postorder_traversal/"
    leetcode-difficulty: easy
    topics: [tree, dfs]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: This is definatly hard if you want to use iterative solution but you didn't come up the `std::reverse` trick.

  - id: 146
    title: "LRU Cache"
    link: "./problems/146_lru_cache/"
    leetcode-difficulty: medium
    topics: [design, linked-list, hashtable, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Always practice. Use std::list + std::unordered_map. please understand why use list"

  - id: 150
    title: "Evaluate Reverse Polish Notation"
    link: "./problems/150_evaluate_reverse_polish_notation/"
    leetcode-difficulty: medium
    topics: [stack, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Edge case are tricky, but the idea is straightforward. Alwasy think when the input is invalid"

  - id: 152
    title: "Maximum Product Subarray"
    link: "./problems/152_maximum_product_subarray/"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150, kadane-algorithm]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: The dp logic is not straightforward. The key is the remember three conditions: positve, negative, zero. Using DP to find max positive and min negative

      Attempt 2: The dp logic is smooth. The problem is the initial value of globalMax, localMax, and localMin, I didn't init it to nums[0] in the first place can cause overflow. After fixing, I use ranged based for, so index 0 is calculated twice which is not acceptable.

  - id: 155
    title: "Min Stack"
    link: "./problems/155_min_stack/"
    leetcode-difficulty: medium
    topics: [stack, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Don't understand the problem

      Attempt 2: I know the key is to maintain two stacks, and I think through the logic, and slowly implement the code correctly. But cannot do it in a flash.

  - id: 167
    title: "Two Sum II - Input Array Is Sorted"
    link: "./problems/167_two_sum_ii_input_array_is_sorted/"
    leetcode-difficulty: easy
    topics: [two-pointer, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "trivial two-pointer"

  - id: 198
    title: "House Robber"
    link: "./problems/198_house_robber/"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means max amount can be robbed from house[0..i]. dp[i] = max(dp[i-1], dp[i-2]+nums[i]). Use foldl to optimize space"

  - id: 199
    title: "Binary Tree Right Side View"
    link: "./problems/199_binary_tree_right_side_view/"
    leetcode-difficulty: medium
    topics: [tree, bfs, dfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: Almost one shot. Only forgot to check the root node is nullptr.

  - id: 206
    title: "Reverse Linked List"
    link: "./problems/206_reverse_linked_list/"
    leetcode-difficulty: easy
    topics: [linked-list, iteration, recursion, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Every time I do this, I feel very frustrated. I know the idea.
        - Iterative: use 3 pointers prev, curr, next. But I cannot implement correctly.
        - Recursive: In Haskell, this is easy `reverse (x:xs) = (reverse xs) ++ [x]`, but I cannot implement it in C++. It is `head->next->next = head; head->next = nullptr; return newHead;`...

      Attempt 2: I use iterative. It is almost an one-shot. Only return I should return prev instead of curr.

  - id: 207
    title: "Course Schedule"
    link: "./problems/207_course_schedule/"
    leetcode-difficulty: medium
    topics: [graph, bfs, dfs, topological-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      BFS or DFS coloring to detect cycle. Or use Kahn's algorithm to do topological sort.

      2nd time re-learn. I use enum-class to define colors. And get it almost right

  - id: 210
    title: "Course Schedule II"
    link: "./problems/210_course_schedule_ii/"
    leetcode-difficulty: medium
    topics: [graph, bfs, dfs, topological-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      First time, now forget how to trace the path

      Second time re-learn. Khan's algorithm is easy to implement. The error I made is indeg[course] == 0, I wrote indeg[course] != 0.

  - id: 211
    title: "Design Add and Search Words Data Structure"
    link: "./problems/211_design_add_and_search_words_data_structure/"
    leetcode-difficulty: medium
    topics: [trie, backtracking, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      When doing rirst time seeing Trie, need to re-learn. The key is the struct (data)

      Second time re-learn, I found myself forgetting the important details, like using `std::unique_ptr`. Also, rememeber to use `auto it = map.emplace(...).first`. Emplace returns a pair<iterator, bool>. We can add (void) infront of emplace if we don't care about the return value.

  - id: 213
    title: "House Robber II"
    link: "./problems/213_house_robber_ii/"
    leetcode-difficulty: medium
    topics: [dp, circular, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Arranged in circle. Two cases: rob house[0..n-2] or house[1..n-1]"

  - id: 217
    title: "Contains Duplicate"
    link: "./problems/217_contains_duplicate/"
    leetcode-difficulty: easy
    topics: [hashset, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "HashSet"

  - id: 226
    title: "Invert Binary Tree"
    link: "./problems/226_invert_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion or Iteration"

  - id: 287
    title: "Find the Duplicate Number"
    link: "./problems/287_find_the_duplicate_number/"
    leetcode-difficulty: medium
    topics: [two-pointer, linked-list-cycle, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: For simple map solution, I can implement it fluently. For the two-pointer solution, this is not intuitive at all. The key is to treat the array as a linked list, and the duplicate number is the entry point of the cycle. Then use Floyd's Tortoise and Hare algorithm to find the entry point.

  - id: 230
    title: "Kth Smallest Element in a BST"
    link: "./problems/230_kth_smallest_element_in_a_bst/"
    leetcode-difficulty: medium
    topics: [tree, dfs, binary-search-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the concept, but implementation has a lot of problems.
        - Recursive solution: I didn't make k and result function arguments as references. I was thinking to put result as return value, but it is not a good idea.
        - Iterative solution: The structure of while loop is totally wrong. I need to practice more.

      Attempt 2: I know the big structure but I have problems with the iterative solution. The key is using `while (curr || !stack.empty())` as the main iterating method, and we should not prevent curr from being null. In fact, we want to see curr is null so that we use pop to backtrack, then go to the right child.

  - id: 238
    title: "Product of Array Except Self"
    link: "./problems/238_product_of_array_except_self/"
    leetcode-difficulty: medium
    topics: [array, prefix-sum, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Prefix and Suffix product arrays, or use output array as prefix product array to save space"

  - id: 239
    title: "Sliding Window Maximum"
    link: "./problems/239_sliding_window_maximum/"
    leetcode-difficulty: hard
    topics: [monotonic-queue, array, sliding-window, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: WTF
      Attempt 2: I can quickly write the whole solution. But there are 2 problems. First, indices are wrong. Second, I caused overflow by not checking (idx >= k) when calculating std::size_t. Be extra cautious when using unsigned types.

  - id: 235
    title: "Lowest Common Ancestor of a Binary Search Tree"
    link: "./problems/235_lowest_common_ancestor_of_a_binary_search_tree/"
    leetcode-difficulty: medium
    topics: [tree, monotonic, dfs, binary-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I didn't write the code correctly in a sprint. But I reframe the question and solve it correctly.

  - id: 278
    title: "First Bad Version"
    link: "./problems/278_first_bad_version/"
    leetcode-difficulty: easy
    topics: [binary-search, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Just standard [start, end) binary search to change the predicate"

  - id: 297
    title: "Serialize and Deserialize Binary Tree"
    link: "./problems/297_serialize_and_deserialize_binary_tree/"
    leetcode-difficulty: hard
    topics: [tree, bfs, dfs, binary-tree, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Core tree logic (BFS traversal) was fine. My main friction point was implementing the string tokenizer from scratch quickly. Need to internalize the `stringstream` + `getline` pattern. Also, remember to handle the trailing comma from serialize.

  - id: 300
    title: "Longest Increasing Subsequence"
    link: "./problems/300_longest_increasing_subsequence/"
    leetcode-difficulty: medium
    topics: [dp, binary-search, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "DP O(n^2) or Binary Search O(n log n). Binary search is never practiced. dp[i] means from nums[0..i], the longest increasing subsequence that ends with nums[i]"

  - id: 310
    title: "Minimum Height Trees"
    link: "./problems/310_minimum_height_trees/"
    leetcode-difficulty: medium
    topics: [graph, bfs, tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Peel off the leaves layer by layer until 1 or 2 nodes left"

  - id: 322
    title: "Coin Change"
    link: "./problems/322_coin_change/"
    leetcode-difficulty: medium
    topics: [dp, bfs, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means the minimum coins to make amount i"

  - id: 347
    title: "Top K Frequent Elements"
    link: "./problems/347_top_k_frequent_elements/"
    leetcode-difficulty: medium
    topics: [hashtable, heap, bucket-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Use HashMap to count frequency, then use Min-Heap or Bucket Sort to get top K. Bucket sort is optimal O(n), but I forget how to implement it"

  - id: 416
    title: "Partition Equal Subset Sum"
    link: "./problems/416_partition_equal_subset_sum/"
    leetcode-difficulty: medium
    topics: [dp, knapsack, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: The first time I need to learn from the answer and learn knapsack. dp[i][j] means using nums[0..i], can we fill a knapsack of capacity j. dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]"

      Attempt 2: Fast implement. Forget to set dp[0] = true. Forget std::accumulate need to add accumulator 0 and include numeric. Should be L2~L3. But I set to L2. Lets practice later.

  - id: 496
    title: "Next Greater Element I"
    link: "./problems/496_next_greater_element_i/"
    leetcode-difficulty: easy
    topics: [monotonic-stack, hashtable, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Monotonic stack."

  - id: 503
    title: "Next Greater Element II"
    link: "./problems/503_next_greater_element_ii/"
    leetcode-difficulty: medium
    topics: [monotonic-stack, array, circular, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Monotonic stack. Circular array can be simulated by iterating 2 times"

  - id: 509
    title: "Fibonacci Number"
    link: "./problems/509_fibonacci_number/"
    leetcode-difficulty: easy
    topics: [dp, recursion, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion with memo or bottom-up DP"

  - id: 543
    title: "Diameter of Binary Tree"
    link: "./problems/543_diameter_of_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, bfs, binary-tree, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion or FOLD"

  - id: 572
    title: "Subtree of Another Tree"
    link: "./problems/572_subtree_of_another_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: Recusive and helper is same funciton can solve the problem. But I think what if we can use KMF algorithm way like structure?

  - id: 647
    title: "Palindromic Substrings"
    link: "./problems/647_palindromic_substrings/"
    leetcode-difficulty: medium
    topics: [dp, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Very similar to 005_Longest_Palindromic_Substring. There are three ways: Expand, 2D-dp, or 1D-dp build up layer by layer"

  - id: 704
    title: "Binary Search"
    link: "./problems/704_binary_search/"
    leetcode-difficulty: easy
    topics: [binary-search, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Standard binary search template"

  - id: 746
    title: "Min Cost Climbing Stairs"
    link: "./problems/746_min_cost_climbing_stairs/"
    leetcode-difficulty: easy
    topics: [dp, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "dp[i] means min cost to reach step i. dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])"

  - id: 852
    title: "Peak Index in a Mountain Array"
    link: "./problems/852_peak_index_in_a_mountain_array/"
    leetcode-difficulty: easy
    topics: [binary-search, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Binary search to find the first location where arr[i] > arr[i+1]"

  - id: 1448
    title: "Count Good Nodes in Binary Tree"
    link: "./problems/1448_count_good_nodes_in_binary_tree/"
    leetcode-difficulty: medium
    topics: [tree, dfs, binary-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Very fun. I thought of using mono-stack, but it is not necessary. Just pass down the max value from root to leaf.

  - id: 3701
    title: "Compute Alternating Sum"
    link: "./problems/3701_compute_alternating_sum/"
    leetcode-difficulty: easy
    topics: [array, leetcode-contest]
    status: L3_MASTERED
    refinement_focus: "Trivial"

  - id: 3702
    title: "Longest Subsequence With Non-Zero Bitwise XOR"
    link: "./problems/3702_longest_subsequence_with_nonzero_bitwise_xor/"
    leetcode-difficulty: medium
    topics: [bit-manipulation, leetcode-contest]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: There are only 3 cases, but I thought we can only solve it by DP.

  - id: 3703
    title: "Remove K-Balanced Substrings"
    link: "./problems/3703_remove_k-balanced_substrings/"
    leetcode-difficulty: medium
    topics: [string, leetcode-contest]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Didn't finish during contest. Use vector<pair<char, int>> to store (char, count) pairs. Then simulate the removal of k-balanced substrings.

  - id: 3712
    title: "Sum of Elements With Frequency Divisible by K"
    link: "./problems/3712_sum_of_elements_with_frequency_divisible_by_k/"
    leetcode-difficulty: easy
    topics: [hashtable, array, leetcode-contest]
    status: L3_MASTERED
    refinement_focus: "Trivial"

  - id: 3713
    title: "Longest Balanced Substring I"
    link: "./problems/3713_longest_balanced_substring_i/"
    leetcode-difficulty: medium
    topics: [string, brute-force, leetcode-contest]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: Didn't finish during contest. I don't even identify this as a brute-force problem.

  - id: 3718
    title: Smallest Missing Multiple of K
    link: "./problems/3718_smallest_missing_multiple_of_k/"
    leetcode-difficulty: easy
    topics: [math, hashtable, iteration, leetcode-contest]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: The return value might be tricky when the largest value is K's multiple.

  - id: 3719
    title: "Longest Balanced Subarray i"
    link: "./problems/3719_longest_balanced_subarray_i/"
    leetcode-difficulty: medium
    topics: [array, hash-set, two-pointer, sliding-window, enumeration]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Starting, when I read the problem, I missed the "distinct" keyword. So I thought of using frequency map to track counts of each number in the window and try to use prefix sum to optimize. But it is too complicated. After realizing "distinct", I can use two-pointer sliding window to solve it easily.

  - id: 3720
    title: "3720. Lexicographically Smallest Permutation Greater Than Target"
    link: "./problems/3720_lexicographically_smallest_permutation_greater_than_target/"
    leetcode-difficulty: medium
    topics: [string, greedy, sorting, counting, hash-table]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: Although I know the basic idea, I cannot correctly implement the greedy algorithm. Even struggled for the whole afternoon. I got very frustrated and tired, and even cannot understand the solution from genmin.

  - id: 3726
    title: "Remove Zeros in Decimal Representation"
    link: "./problems/3726_remove_zeros_in_decimal_representation/"
    topics: [string, weekly-contest]
    status: L3_MASTERED
    refinement_focus: "Simple std::to_string and std::stll"

  - id: 3727
    title: "Maximum Alternating Sum of Squares"
    link: "./problems/3727_maximum_alternating_sum_of_squares/"
    topics: [greedy, sorting, weekly-contest]
    status: L3_MASTERED
    refinement_focus: "Greedy"

  - id: 3728
    title: "Stable Subarrays With Equal Boundary and Interior Sum"
    link: "./problems/3728_stable_subarrays_with_equal_boundary_and_interior_sum/"
    topics: [prefix-sum, subarray, weekly-contest]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Tried brute-force first, TLE. Then, prefix-sum, TLE. Then, prefix-sum + hash-map for same l,r value, TLE. Gemini's solution is not very intuitive. It keeps track of prefix-sum and index in a hash-map, so that we can find all possible pairs for every r.