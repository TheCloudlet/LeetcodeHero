# =============================================================================
# LeetCode Hero - Cultivation Progress Database
# =============================================================================
# This database tracks your mastery level and progress on LeetCode problems
# for technical interview preparation, particularly focused on Google-style
# algorithmic challenges.
#
# STATUS DEFINITIONS:
# -------------------
# L1_FORGOT    (忘) - Problem completely forgotten, requires re-learning from scratch
# L2_STRUGGLE  (解) - Can solve but with difficulty, not interview-ready yet
# L3_MASTERED  (定) - Can solve within 20 minutes, bug-free, handling all edge cases
#
# FIELD DESCRIPTIONS:
# -------------------
# id:                  LeetCode problem number
# title:               Official problem title from LeetCode
# link:                Relative path to your solution folder
# leetcode-difficulty: Official difficulty (easy/medium/hard)
# topics:              Algorithm/data structure tags for categorization
# status:              Your current mastery level (L1_FORGOT/L2_STRUGGLE/L3_MASTERED)
# refinement_focus:    Specific areas to improve or key insights to remember
#
# TOPIC TAGS:
# -----------
# Common tags include: hashtable, hashset, array, linked-list, stack, queue,
# binary-search, two-pointer, sliding-window, dp, backtracking, graph, tree,
# sorting, string, math, greedy, neetcode150
#
# ENTRY TEMPLATE:
# ---------------
#  - id:
#    title: ""
#    link: "./"
#    leetcode-difficulty:
#    topics:
#    status:
#    refinement_focus: ""
#
# =============================================================================

problems:
  - id: 1
    title: "Two Sum"
    link: "./problems/001_two_sum/"
    leetcode-difficulty: easy
    topics: [hashtable, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Try 1: Use hashmap
      Try 2: I use sorted with pair, and two pointer

  - id: 2
    title: "Add Two Numbers"
    link: "./problems/002_add_two_numbers/"
    leetcode-difficulty: medium
    topics: [linked-list, indirect-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Try 1: Indirect-pointer and sum/carry handling

      Try 2: Sum/carry is correctly handled, but indirect pointer usage is incorrect. The resultHead and indirect-pointer declarations are poorly structured. Also, (*indirect) = new ListNode(val); is unclear. I incorrectly wrote indirect = &(new ListNode());

  - id: 3
    title: "Longest Substring Without Repeating Characters"
    link: "./problems/003_longest_substring_without_repeating_characters/"
    leetcode-difficulty: medium
    topics: [hashtable, sliding-window, string, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      #1: 通常這種題目 While 的使用是關鍵
      #2: re-learn using std::vector<int> last_seen(128, -1)

  - id: 5
    title: "Longest Palindromic Substring"
    link: "./problems/005_longest_palindromic_substring/"
    leetcode-difficulty: medium
    topics: [iteration, dp, manachers-algorithm, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Expand, DP, or Manacher's algorithm"

  - id: 6
    title: "Zigzag Conversion"
    link: "./problems/006_zigzag_conversion/"
    leetcode-difficulty: medium
    topics: [vector, string]
    status: L3_MASTERED
    refinement_focus: "Updown traverse and push to vector"

  - id: 7
    title: "Reverse Integer"
    link: "./problems/007_reverse_integer/"
    leetcode-difficulty: medium
    topics: [integer, signed, boundary]
    status: L2_STRUGGLE
    refinement_focus: "The key is boundary + minus"

  - id: 8
    title: "String to Integer"
    link: "./problems/008_string_to_integer/"
    leetcode-difficulty: medium
    topics: [parsing, stoi, boundary, signed, overflow]
    status: L3_MASTERED
    refinement_focus: "boundary + minus"

  - id: 9
    title: "Palindrome Number"
    link: "./problems/009_palindrome_number/"
    leetcode-difficulty: easy
    topics: [iteration]
    status: L3_MASTERED
    refinement_focus: |
      std::to_string while
      Count: 2


  - id: 11
    title: "Container With Most Water"
    link: "./problems/011_container_with_most_water/"
    leetcode-difficulty: medium
    topics: [two-pointer, array, greedy, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "find the smallest of the two sides, and move the pointer"

  - id: 12
    title: "Integer to Roman"
    link: "./problems/012_integer_to_roman/"
    leetcode-difficulty: medium
    topics: [array]
    status: L2_STRUGGLE
    refinement_focus: "Transform roman to (value, string) pair and decode greedy"

  - id: 13
    title: "Roman to Integer"
    link: "./problems/013_roman_to_integer/"
    leetcode-difficulty: easy
    topics: [array]
    status: L2_STRUGGLE
    refinement_focus: "Need to peek next, to know current is + or -"

  - id: 14
    title: "Longest Common Prefix"
    link: "./problems/014_longest_common_prefix/"
    leetcode-difficulty: easy
    topics: [array]
    status: L3_MASTERED
    refinement_focus: |
      The clean solution is to take the first string as golden
      #2: misplaced inner and outer for-loop

  - id: 15
    title: "3 Sum"
    link: "./problems/015_3sum/"
    leetcode-difficulty: medium
    topics: [two-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Dupicates handling is tricky"

  - id: 16
    title: "3 Sum Closest"
    link: "./problems/016_3sum_closest/"
    leetcode-difficulty: medium
    topics: [two-pointer, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "Same as 015_3Sum, but need to track closest value"

  - id: 17
    title: "Letter Combinations of a Phone Number"
    link: "./problems/017_letter_combinations_of_a_phone_number/"
    leetcode-difficulty: medium
    topics: [hashtable, backtracking, string]
    status: L3_MASTERED
    refinement_focus: "Write a good helper pure function"

  - id: 18
    title: "4 Sum"
    link: "./problems/018_4sum/"
    leetcode-difficulty: medium
    topics: [k-sum, two-pointer, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "generalizing k-sum function"

  - id: 19
    title: "Remove Nth Node From End of List"
    link: "./problems/019_remove_nth_node_from_end_of_list/"
    leetcode-difficulty: medium
    topics: [fast-and-slow-pointer, linked-list, indirect-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Indirect-pointer and fast/slow pointer"

  - id: 20
    title: "Valid Parentheses"
    link: "./problems/020_valid_parentheses/"
    leetcode-difficulty: easy
    topics: [stack, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "I know the stack solution, but I cannot execute it fluently and elegantly"

  - id: 21
    title: "Merge Two Sorted Lists"
    link: "./problems/021_merge_two_sorted_lists/"
    leetcode-difficulty: easy
    topics: [linked-list, indirect-pointer, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: Normal dummy node is okay. But I forget indirect-pointer usage. Always use `ListNode *result;` then `ListNode **indirect = &result;`

      Attempt 2: One-shot using indirect pointer. But a little uncertain when doing it in a sprint.

  - id: 22
    title: "Generate Parentheses"
    link: "./problems/022_generate_parentheses/"
    leetcode-difficulty: medium
    topics: [backtracking, string]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the core idea, implement has some flaws.

  - id: 23
    title: "Merge k Sorted Lists"
    link: "./problems/023_merge_k_sorted_lists/"
    leetcode-difficulty: hard
    topics: [linked-list, heap, priority-queue, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Not really hard, but I need to review how to initialize a priority queue and also prevent adding nullptr to the queue. There are also one way to use merge sort to merge k lists.

  - id: 24
    title: "Swap Nodes in Pairs"
    link: "./problems/024_swap_nodes_in_pairs/"
    leetcode-difficulty: medium
    topics: [linked-list, indirect-pointer, recursion]
    status: L2_STRUGGLE
    refinement_focus: "While loop or helper recursion"

  - id: 25
    title: "Reverse Nodes in k-Group"
    link: "./problems/025_reverse_nodes_in_k-group/"
    leetcode-difficulty: hard
    topics: [linked-list, indirect-pointer, recursion, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |

  - id: 33
    title: "Search in Rotated Sorted Array"
    link: "./problems/033_search_in_rotated_sorted_array/"
    leetcode-difficulty: medium
    topics: [binary-search, array, sorting]
    status: L1_FORGOT
    refinement_focus: |
      #1: (1) we should check whether is left sorted or right sorted (monotonic)
          (2) we should be very careful about the boundary conditions if there are only 2 elements left

  - id: 34
    title: "Find First and Last Position of Element in Sorted Array"
    link: "./problems/034_find_first_and_last_position_of_element_in_sorted_array/"
    leetcode-difficulty: medium
    topics: [binary-search, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "lower_bound and upper_bound"

  - id: 35
    title: "Search Insert Position"
    link: "./problems/035_search_insert_position/"
    leetcode-difficulty: easy
    topics: [binary-search, array, sorting]
    status: L3_MASTERED
    refinement_focus: "lower_bound"

  - id: 36
    title: "Valid Sudoku"
    link: "./problems/036_valid_sudoku/"
    leetcode-difficulty: medium
    topics: [hashset, matrix, simulation, neetcode150]
    status: L3_MASTERED
    refinement_focus: "HashSet"

  - id: 42
    title: "Trapping Rain Water"
    link: "./problems/042_trapping_rain_water/"
    leetcode-difficulty: hard
    topics: [two-pointer, monotonic-stack, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "next-greater-element or two-pointer"

  - id: 48
    title: "Rotate Image"
    link: "./problems/048_rotate_image/"
    leetcode-difficulty: medium
    topics: [matrix]
    status: L3_MASTERED
    refinement_focus: "Transpose + Reverse"

  - id: 49
    title: "Group Anagrams"
    link: "./problems/049_group_anagrams/"
    leetcode-difficulty: medium
    topics: [hashtable, string, sorting, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Sorting"

  - id: 53
    title: "Maximum Subarray"
    link: "./problems/053_maximum_subarray/"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150, kadane-algorithm]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: One shot Kadane's algorithm after praticing LeetCode #152.

  - id: 56
    title: "Merge Intervals"
    link: "./problems/056_merge_intervals/"
    leetcode-difficulty: medium
    topics: [array, sorting, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Sorting + Iterate and Merge"

  - id: 57
    title: "Insert Interval"
    link: "./problems/057_insert_interval/"
    leetcode-difficulty: medium
    topics: [array, sorting, neetcode150]
    status: L2_STRUGGLE
    refinement_focus:
      #1: Copy before insertion, merge overlaps, then append the rest

  - id: 61
    title: "Rotate List"
    link: "./problems/061_rotate_list/"
    leetcode-difficulty: medium
    topics: [linked-list, two-pointer, indirect-pointer]
    status: L3_MASTERED
    refinement_focus: "Make the list circular first. There are optimiazations like if k == length, do nothing"

  - id: 66
    title: "Plus One"
    link: "./problems/066_plus_one/"
    leetcode-difficulty: easy
    topics: [array, math]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: (Pass 15) But the simplest way is to use vector::insert to insert 1 at the beginning if there is a carry at the end.

  - id: 70
    title: "Climbing Stairs"
    link: "./problems/070_climbing_stairs/"
    leetcode-difficulty: easy
    topics: [dp, math, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Fibonacci, bottom-up DP, top-down DP, or even math"

  - id: 76
    title: "Minimum Window Substring"
    link: "./problems/076_minimum_window_substring/"
    leetcode-difficulty: hard
    topics: [hashtable, sliding-window, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      #1: Brute force but got TLE. Then used sliding window. I don't know when to use sliding window or brute force. The note is written in the #3719 solution.
      #2: I can implement the solution using a map counter, but this is not very elegant. The best solution is to use a vector as a dictionary, plus using a total count variable to track all characters in t. Expand and shrink the window based on the total count.

  - id: 84
    title: "Largest Rectangle in Histogram"
    link: "./problems/084_largest_rectangle_in_histogram/"
    leetcode-difficulty: hard
    topics: [stack, array, monotonic-stack, neetcode150]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: (Fail 15 + 45) The key is to find the nearest smaller element on both sides for each bar. Use monotonic stack to achieve O(n) time complexity.

  - id: 91
    title: "Decode Ways"
    link: "./problems/091_decode_ways/"
    leetcode-difficulty: medium
    topics: [dp, string, backtracking, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means ways to decode s[0..i-1]. Also, we need to handle 1 digit and 2 digit separately"

  - id: 94
    title: "Binary Tree Inorder Traversal"
    link: "./problems/094_binary_tree_inorder_traversal/"
    leetcode-difficulty: easy
    topics: [tree, dfs]
    status: L2_STRUGGLE
    refinement_focus: "Just finish after #230 so it is a one shot. But I still recomment to practice more."

  - id: 96
    title: "Unique Binary Search Trees"
    link: "./problems/096_unique_binary_search_trees/"
    leetcode-difficulty: medium
    topics: [dp, math, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[n] means number of unique BST that can be built with n nodes. dp[n] = sum of dp[i-1]*dp[n-i] for i in [1..n]. Catalan number"

  - id: 98
    title: "Validate Binary Search Tree"
    link: "./problems/098_validate_binary_search_tree/"
    leetcode-difficulty: medium
    topics: [tree, dfs, binary-tree, neetcode150]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: I only validate all nodes (node->val vs node->left->val) recursively. But actually we need to pass down the valid range (min, max) from root to leaf.

  - id: 100
    title: "Same Tree"
    link: "./problems/100_same_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion"

  - id: 102
    title: "Binary Tree Level Order Traversal"
    link: "./problems/102_binary_tree_level_order_traversal/"
    leetcode-difficulty: medium
    topics: [tree, traversal, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Use nullptr in a queue to mark level end. But I forget to check if the current queue is empty which means we are done. So it causes infinite loop.

  - id: 105
    title: "Construct Binary Tree from Preorder and Inorder Traversal"
    link: "./problems/105_construct_binary_tree_from_preorder_and_inorder_traversal/"
    leetcode-difficulty: medium
    topics: [tree, dfs, recursion, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the idea, but I cannot implement it fluently. The key is to correctly manage the indices of preorder and inorder arrays. Forgot to check if the current subtree is empty (preStart > preEnd || inStart > inEnd)

  - id: 110
    title: "Balanced Binary Tree"
    link: "./problems/110_balanced_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Reviewed the definition of balanced biniary tree. Implementation is smooth, but I forgot to (add 1) when calculating height.

  - id: 104
    title: "Maximum Depth of Binary Tree"
    link: "./problems/104_maximum_depth_of_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Basic DP"

  - id: 124
    title: "Binary Tree Maximum Path Sum"
    link: "./problems/124_binary_tree_maximum_path_sum/"
    leetcode-difficulty: hard
    topics: [tree, dfs, binary-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
       #1: I have a clear understanding of the code structure, i.e., need a helper function that returns two values as an accumulator. There are two parts that I did not handle correctly. First, if there is only one negative value node, my base case will cause the max path to be 0. So the base case should return INT_MIN. Second, if a node has one negative child path and one positive child path, we need to discard the negative one, i.e., use std::max(0, lPathToLeaf). In sum, this needs more practice.
       
       #2: basically correct, but I need to be more careful about the base case. We should return {INT_MIN, 0} instead of {0, 0} 

  - id: 125
    title: "Valid Palindrome"
    link: "./problems/125_valid_palindrome/"
    leetcode-difficulty: easy
    topics: [two-pointer, string, neetcode150]
    status: L3_MASTERED
    refinement_focus: "isalnum() and tolower()"

  - id: 128
    title: "Longest Consecutive Sequence"
    link: "./problems/128_longest_consecutive_sequence/"
    leetcode-difficulty: medium
    topics: [hashset, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "sort is O(n log n), use HashSet to achieve O(n). Check only sequence starters"

  - id: 138
    title: "Copy List with Random Pointer"
    link: "./problems/138_copy_list_with_random_pointer/"
    leetcode-difficulty: medium
    topics: [linked-list, hashtable, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: One-shot with HashMap.

  - id: 139
    title: "Word Break"
    link: "./problems/139_word_break/"
    leetcode-difficulty: medium
    topics: [dp, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Not absolutely sure I can get this right during interview, but I know the idea. ip[i] means s[i..end] can be segmented. Need a helper function isPrefix and a recursive function with memo"

  - id: 141
    title: "Linked List Cycle"
    link: "./problems/141_linked_list_cycle/"
    leetcode-difficulty: easy
    topics: [linked-list, two-pointer, fast-and-slow-pointer, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: I know the fast/slow pointer idea, but I cannot implement it fluently. The key is to check if fast and fast->next are nullptr directly in the while loop condition.

      Attempt 2: One-shot

  - id: 143
    title: "Reorder List"
    link: "./problems/143_reorder_list/"
    leetcode-difficulty: medium
    topics: [linked-list, two-pointer, fast-and-slow-pointer, reverse, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the big picture. But failed at finding the mid node. I used `while (fast && fast->next)` which makes slow point to the second middle node in even-length list. So when merging, the first half is longer than the second half by one node, which causes problem.

  - id: 144
    title: "Binary Tree Preorder Traversal"
    link: "./problems/144_binary_tree_preorder_traversal/"
    leetcode-difficulty: easy
    topics: [tree, dfs]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Easier than inorder or Postorder iterative solution. But I still have problems with the structure of while loop. I need to practice more.

  - id: 145
    title: "Binary Tree Postorder Traversal"
    link: "./problems/145_binary_tree_postorder_traversal/"
    leetcode-difficulty: easy
    topics: [tree, dfs]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: This is definatly hard if you want to use iterative solution but you didn't come up the `std::reverse` trick.

  - id: 146
    title: "LRU Cache"
    link: "./problems/146_lru_cache/"
    leetcode-difficulty: medium
    topics: [design, linked-list, hashtable, neetcode150]
    status: L1_FORGOT
    refinement_focus: | 
      #1: Always practice. Use std::list + std::unordered_map. please understand why use list
      #2: failed the second time, the reason is `iterator usage`, `splice` and reusing the last node.

  - id: 150
    title: "Evaluate Reverse Polish Notation"
    link: "./problems/150_evaluate_reverse_polish_notation/"
    leetcode-difficulty: medium
    topics: [stack, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Edge case are tricky, but the idea is straightforward. Alwasy think when the input is invalid"

  - id: 152
    title: "Maximum Product Subarray"
    link: "./problems/152_maximum_product_subarray/"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150, kadane-algorithm]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: The dp logic is not straightforward. The key is the remember three conditions: positve, negative, zero. Using DP to find max positive and min negative

      Attempt 2: The dp logic is smooth. The problem is the initial value of globalMax, localMax, and localMin, I didn't init it to nums[0] in the first place can cause overflow. After fixing, I use ranged based for, so index 0 is calculated twice which is not acceptable.

  - id: 153
    title: "Find Minimum in Rotated Sorted Array"
    link: "./problems/153_find_minimum_in_rotated_sorted_array/"
    leetcode-difficulty: medium
    topics: [binary-search, array, sorting, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      #1: Used `while (left <= right)` and got AC, but Gemini suggested `while (left < right)` as it is less error-prone. Learned the binary search decision-making process. Plan to redo this.

  - id: 155
    title: "Min Stack"
    link: "./problems/155_min_stack/"
    leetcode-difficulty: medium
    topics: [stack, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Don't understand the problem

      Attempt 2: I know the key is to maintain two stacks, and I think through the logic, and slowly implement the code correctly. But cannot do it in a flash.

  - id: 162
    title: "Find Peak Element"
    link: "./problems/162_find_peak_element/"
    leetcode-difficulty: medium
    topics: [binary-search, array]
    status: L2_STRUGGLE
    refinement_focus: |
      #1: Easy solution after doing LC33, LC153, LC704 in a row.

  - id: 167
    title: "Two Sum II - Input Array Is Sorted"
    link: "./problems/167_two_sum_ii_input_array_is_sorted/"
    leetcode-difficulty: easy
    topics: [two-pointer, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "trivial two-pointer"

  - id: 198
    title: "House Robber"
    link: "./problems/198_house_robber/"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means max amount can be robbed from house[0..i]. dp[i] = max(dp[i-1], dp[i-2]+nums[i]). Use foldl to optimize space"

  - id: 199
    title: "Binary Tree Right Side View"
    link: "./problems/199_binary_tree_right_side_view/"
    leetcode-difficulty: medium
    topics: [tree, bfs, dfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: Almost one shot. Only forgot to check the root node is nullptr.
  
  - id: 200
    title: "Number of Islands"
    link: "./problems/200_number_of_islands/"
    leetcode-difficulty: medium
    topics: [array, depth-first-search, matrix]
    status: L2_STRUGGLE 
    refinement_focus: |
      Attempt 1: One-shot, but ugly. Key is `constexpr dirs[4][2]` and use `auto dfs = [&](auto &&dfs, int r, int c) -> void`.

  - id: 206
    title: "Reverse Linked List"
    link: "./problems/206_reverse_linked_list/"
    leetcode-difficulty: easy
    topics: [linked-list, iteration, recursion, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Every time I do this, I feel very frustrated. I know the idea.
        - Iterative: use 3 pointers prev, curr, next. But I cannot implement correctly.
        - Recursive: In Haskell, this is easy `reverse (x:xs) = (reverse xs) ++ [x]`, but I cannot implement it in C++. It is `head->next->next = head; head->next = nullptr; return newHead;`...

      Attempt 2: I use iterative. It is almost an one-shot. Only return I should return prev instead of curr.

  - id: 207
    title: "Course Schedule"
    link: "./problems/207_course_schedule/"
    leetcode-difficulty: medium
    topics: [graph, bfs, dfs, topological-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      BFS or DFS coloring to detect cycle. Or use Kahn's algorithm to do topological sort.

      2nd time re-learn. I use enum-class to define colors. And get it almost right

  - id: 209
    title: "Minimum Size Subarray Sum"
    link: "./problems/209_minimum_size_subarray_sum/"
    leetcode-difficulty: medium
    topics: [sliding-window, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      #1: One-shot.

  - id: 210
    title: "Course Schedule II"
    link: "./problems/210_course_schedule_ii/"
    leetcode-difficulty: medium
    topics: [graph, bfs, dfs, topological-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      First time, now forget how to trace the path

      Second time re-learn. Khan's algorithm is easy to implement. The error I made is indeg[course] == 0, I wrote indeg[course] != 0.

  - id: 211
    title: "Design Add and Search Words Data Structure"
    link: "./problems/211_design_add_and_search_words_data_structure/"
    leetcode-difficulty: medium
    topics: [trie, backtracking, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      When doing rirst time seeing Trie, need to re-learn. The key is the struct (data)

      Second time re-learn, I found myself forgetting the important details, like using `std::unique_ptr`. Also, rememeber to use `auto it = map.emplace(...).first`. Emplace returns a pair<iterator, bool>. We can add (void) infront of emplace if we don't care about the return value.

  - id: 213
    title: "House Robber II"
    link: "./problems/213_house_robber_ii/"
    leetcode-difficulty: medium
    topics: [dp, circular, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Arranged in circle. Two cases: rob house[0..n-2] or house[1..n-1]"

  - id: 217
    title: "Contains Duplicate"
    link: "./problems/217_contains_duplicate/"
    leetcode-difficulty: easy
    topics: [hashset, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "HashSet"

  - id: 226
    title: "Invert Binary Tree"
    link: "./problems/226_invert_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion or Iteration"

  - id: 287
    title: "Find the Duplicate Number"
    link: "./problems/287_find_the_duplicate_number/"
    leetcode-difficulty: medium
    topics: [two-pointer, linked-list-cycle, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: For simple map solution, I can implement it fluently. For the two-pointer solution, this is not intuitive at all. The key is to treat the array as a linked list, and the duplicate number is the entry point of the cycle. Then use Floyd's Tortoise and Hare algorithm to find the entry point.

  - id: 230
    title: "Kth Smallest Element in a BST"
    link: "./problems/230_kth_smallest_element_in_a_bst/"
    leetcode-difficulty: medium
    topics: [tree, dfs, binary-search-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I know the concept, but implementation has a lot of problems.
        - Recursive solution: I didn't make k and result function arguments as references. I was thinking to put result as return value, but it is not a good idea.
        - Iterative solution: The structure of while loop is totally wrong. I need to practice more.

      Attempt 2: I know the big structure but I have problems with the iterative solution. The key is using `while (curr || !stack.empty())` as the main iterating method, and we should not prevent curr from being null. In fact, we want to see curr is null so that we use pop to backtrack, then go to the right child.

  - id: 238
    title: "Product of Array Except Self"
    link: "./problems/238_product_of_array_except_self/"
    leetcode-difficulty: medium
    topics: [array, prefix-sum, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Prefix and Suffix product arrays, or use output array as prefix product array to save space"

  - id: 239
    title: "Sliding Window Maximum"
    link: "./problems/239_sliding_window_maximum/"
    leetcode-difficulty: hard
    topics: [monotonic-queue, array, sliding-window, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: WTF
      Attempt 2: I can quickly write the whole solution. But there are 2 problems. First, indices are wrong. Second, I caused overflow by not checking (idx >= k) when calculating std::size_t. Be extra cautious when using unsigned types.

  - id: 235
    title: "Lowest Common Ancestor of a Binary Search Tree"
    link: "./problems/235_lowest_common_ancestor_of_a_binary_search_tree/"
    leetcode-difficulty: medium
    topics: [tree, monotonic, dfs, binary-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: I didn't write the code correctly in a sprint. But I reframe the question and solve it correctly.
  
  - id: 236
    title: "Lowest Common Ancestor of a Binary Tree"
    link: "./problems/236_lowest_common_ancestor_of_a_binary_tree/"
    leetcode-difficulty: medium
    topics: [tree, dfs, binary-tree]
    status: L2_STRUGGLE
    refinement_focus: |
      #1: My soultion is to trace all path to p, and trace all path to q. Then iterate the longest two vector. But this best solution is the use recusive found or not.

  - id: 278
    title: "First Bad Version"
    link: "./problems/278_first_bad_version/"
    leetcode-difficulty: easy
    topics: [binary-search, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Just standard [start, end) binary search to change the predicate"

  - id: 297
    title: "Serialize and Deserialize Binary Tree"
    link: "./problems/297_serialize_and_deserialize_binary_tree/"
    leetcode-difficulty: hard
    topics: [tree, bfs, dfs, binary-tree, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Core tree logic (BFS traversal) was fine. My main friction point was implementing the string tokenizer from scratch quickly. Need to internalize the `stringstream` + `getline` pattern. Also, remember to handle the trailing comma from serialize.

  - id: 300
    title: "Longest Increasing Subsequence"
    link: "./problems/300_longest_increasing_subsequence/"
    leetcode-difficulty: medium
    topics: [dp, binary-search, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "DP O(n^2) or Binary Search O(n log n). Binary search is never practiced. dp[i] means from nums[0..i], the longest increasing subsequence that ends with nums[i]"

  - id: 310
    title: "Minimum Height Trees"
    link: "./problems/310_minimum_height_trees/"
    leetcode-difficulty: medium
    topics: [graph, bfs, tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Peel off the leaves layer by layer until 1 or 2 nodes left"

  - id: 322
    title: "Coin Change"
    link: "./problems/322_coin_change/"
    leetcode-difficulty: medium
    topics: [dp, bfs, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means the minimum coins to make amount i"

  - id: 347
    title: "Top K Frequent Elements"
    link: "./problems/347_top_k_frequent_elements/"
    leetcode-difficulty: medium
    topics: [hashtable, heap, bucket-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Use HashMap to count frequency, then use Min-Heap or Bucket Sort to get top K. Bucket sort is optimal O(n), but I forget how to implement it"

  - id: 416
    title: "Partition Equal Subset Sum"
    link: "./problems/416_partition_equal_subset_sum/"
    leetcode-difficulty: medium
    topics: [dp, knapsack, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: The first time I need to learn from the answer and learn knapsack. dp[i][j] means using nums[0..i], can we fill a knapsack of capacity j. dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]"

      Attempt 2: Fast implement. Forget to set dp[0] = true. Forget std::accumulate need to add accumulator 0 and include numeric. Should be L2~L3. But I set to L2. Lets practice later.

  - id: 435
    title: "Non-overlapping Intervals"
    link: "./problems/435_non_overlapping_intervals/"
    leetcode-difficulty: medium
    topics: [greedy, sorting, neetcode150]
    status: L1_FORGOT
    refinement_focus: |
      #1: Greedy. Sort by end time. Then iterate and merge overlaps."

  - id: 496
    title: "Next Greater Element I"
    link: "./problems/496_next_greater_element_i/"
    leetcode-difficulty: easy
    topics: [monotonic-stack, hashtable, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Monotonic stack."

  - id: 503
    title: "Next Greater Element II"
    link: "./problems/503_next_greater_element_ii/"
    leetcode-difficulty: medium
    topics: [monotonic-stack, array, circular, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Monotonic stack. Circular array can be simulated by iterating 2 times"

  - id: 509
    title: "Fibonacci Number"
    link: "./problems/509_fibonacci_number/"
    leetcode-difficulty: easy
    topics: [dp, recursion, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion with memo or bottom-up DP"

  - id: 543
    title: "Diameter of Binary Tree"
    link: "./problems/543_diameter_of_binary_tree/"
    leetcode-difficulty: easy
    topics: [tree, bfs, binary-tree, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion or FOLD"

  - id: 572
    title: "Subtree of Another Tree"
    link: "./problems/572_subtree_of_another_tree/"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: Recusive and helper is same funciton can solve the problem. But I think what if we can use KMF algorithm way like structure?

  - id: 647
    title: "Palindromic Substrings"
    link: "./problems/647_palindromic_substrings/"
    leetcode-difficulty: medium
    topics: [dp, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Very similar to 005_Longest_Palindromic_Substring. There are three ways: Expand, 2D-dp, or 1D-dp build up layer by layer"

  - id: 704
    title: "Binary Search"
    link: "./problems/704_binary_search/"
    leetcode-difficulty: easy
    topics: [binary-search, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
        #1: Standard binary search template
        #2: I use `while(lo < hi)` at the first try
            - `while(lo < hi)` is for finding boundary
            - `while(lo <= hi)` is for exact match

  - id: 746
    title: "Min Cost Climbing Stairs"
    link: "./problems/746_min_cost_climbing_stairs/"
    leetcode-difficulty: easy
    topics: [dp, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "dp[i] means min cost to reach step i. dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])"

  - id: 852
    title: "Peak Index in a Mountain Array"
    link: "./problems/852_peak_index_in_a_mountain_array/"
    leetcode-difficulty: easy
    topics: [binary-search, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
        #1: Binary search to find the first location where arr[i] > arr[i+1]
        #2: I thought I can aced it... AC, but has flaws. I used while (lo <= hi) and use double way check which is not needed.

  - id: 994
    title: "Rotting Oranges"
    link: "./problems/994_rotting_oranges/"
    leetcode-difficulty: medium
    topics: [array, breadth-first-search, matrix]
    status: L3_MASTERED
    refinement_focus: |
      #1: I used simulation with a queue to store the oranges that are going to rot, then update the grid. But this is slow. I should use *multi-source BFS* to speed up the simulation. (level order traversal one example for multi-source BFS)
      From SICP's view, the *multi-source BFS* is
      #+begin_src racket
      (define (expand frontier grid seen)
        ;; returns next-frontier and updated seen
      )
      #+end_src
      - process =expand= stays the same, initial state is kept changing
      - initial state is the set of all rotten oranges

  - id: 1448
    title: "Count Good Nodes in Binary Tree"
    link: "./problems/1448_count_good_nodes_in_binary_tree/"
    leetcode-difficulty: medium
    topics: [tree, dfs, binary-tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Very fun. I thought of using mono-stack, but it is not necessary. Just pass down the max value from root to leaf.

  - id: 3701
    title: "Compute Alternating Sum"
    link: "./problems/3701_compute_alternating_sum/"
    leetcode-difficulty: easy
    topics: [array, leetcode-contest]
    status: L3_MASTERED
    refinement_focus: "Trivial"

  - id: 3702
    title: "Longest Subsequence With Non-Zero Bitwise XOR"
    link: "./problems/3702_longest_subsequence_with_nonzero_bitwise_xor/"
    leetcode-difficulty: medium
    topics: [bit-manipulation, leetcode-contest]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: There are only 3 cases, but I thought we can only solve it by DP.

  - id: 3703
    title: "Remove K-Balanced Substrings"
    link: "./problems/3703_remove_k-balanced_substrings/"
    leetcode-difficulty: medium
    topics: [string, leetcode-contest]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Didn't finish during contest. Use vector<pair<char, int>> to store (char, count) pairs. Then simulate the removal of k-balanced substrings.

  - id: 3712
    title: "Sum of Elements With Frequency Divisible by K"
    link: "./problems/3712_sum_of_elements_with_frequency_divisible_by_k/"
    leetcode-difficulty: easy
    topics: [hashtable, array, leetcode-contest]
    status: L3_MASTERED
    refinement_focus: "Trivial"

  - id: 3713
    title: "Longest Balanced Substring I"
    link: "./problems/3713_longest_balanced_substring_i/"
    leetcode-difficulty: medium
    topics: [string, brute-force, leetcode-contest]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: Didn't finish during contest. I don't even identify this as a brute-force problem.

  - id: 3718
    title: Smallest Missing Multiple of K
    link: "./problems/3718_smallest_missing_multiple_of_k/"
    leetcode-difficulty: easy
    topics: [math, hashtable, iteration, leetcode-contest]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: The return value might be tricky when the largest value is K's multiple.

  - id: 3719
    title: "Longest Balanced Subarray i"
    link: "./problems/3719_longest_balanced_subarray_i/"
    leetcode-difficulty: medium
    topics: [array, hash-set, two-pointer, sliding-window, enumeration]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Starting, when I read the problem, I missed the "distinct" keyword. So I thought of using frequency map to track counts of each number in the window and try to use prefix sum to optimize. But it is too complicated. After realizing "distinct", I can use two-pointer sliding window to solve it easily.

  - id: 3720
    title: "3720. Lexicographically Smallest Permutation Greater Than Target"
    link: "./problems/3720_lexicographically_smallest_permutation_greater_than_target/"
    leetcode-difficulty: medium
    topics: [string, greedy, sorting, counting, hash-table]
    status: L1_FORGOT
    refinement_focus: |
      Attempt 1: Although I know the basic idea, I cannot correctly implement the greedy algorithm. Even struggled for the whole afternoon. I got very frustrated and tired, and even cannot understand the solution from genmin.

  - id: 3726
    title: "Remove Zeros in Decimal Representation"
    link: "./problems/3726_remove_zeros_in_decimal_representation/"
    topics: [string, weekly-contest]
    status: L3_MASTERED
    refinement_focus: "Simple std::to_string and std::stll"

  - id: 3727
    title: "Maximum Alternating Sum of Squares"
    link: "./problems/3727_maximum_alternating_sum_of_squares/"
    topics: [greedy, sorting, weekly-contest]
    status: L3_MASTERED
    refinement_focus: "Greedy"

  - id: 3728
    title: "Stable Subarrays With Equal Boundary and Interior Sum"
    link: "./problems/3728_stable_subarrays_with_equal_boundary_and_interior_sum/"
    topics: [prefix-sum, subarray, weekly-contest]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Tried brute-force first, TLE. Then, prefix-sum, TLE. Then, prefix-sum + hash-map for same l,r value, TLE. Gemini's solution is not very intuitive. It keeps track of prefix-sum and index in a hash-map, so that we can find all possible pairs for every r.
