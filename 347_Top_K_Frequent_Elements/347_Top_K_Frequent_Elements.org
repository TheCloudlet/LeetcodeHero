#+title: 347 Top K Frequent Elements

* Thinking
- Pattern: find max --> heap
- Pattern: count frequency --> hash map

* Learning
** Syntax of ~priority_queue~
** auto cmp
** When to use move, when to not use?
Using ~std::move()~ is beneficial when transferring ownership of expensive-to-copy objects. For primitive types like `int`, there's no benefit because they're already cheap to copy.
General rules for when to use `std::move()` in C++:
1. Use for transferring ownership of heavy objects (vectors, strings, custom classes)
2. Don't use for primitive types (int, char, bool, etc.)
3. Don't use for objects you need to use again later
4. Best used when returning large objects from functions or storing in containers


* Code
#+BEGIN_SRC cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        std::unordered_map<int, int> freqCount;
        for (const auto &i : nums) {
            freqCount[i]++;
        }

        auto cmp = [](const std::pair<int, int> &a,
                      const std::pair<int, int> &b) {
            return a.second < b.second;
        };
        std::priority_queue<std::pair<int, int>,
                    std::vector<std::pair<int, int>>,
                    decltype(cmp)> maxHeap(cmp);

        for (auto &pair : freqCount) {
            maxHeap.push(pair);
        }

        vector<int> result;
        for (int i = 0; i < k; i++) {
            auto [key, value] = maxHeap.top();
            maxHeap.pop();
            result.push_back(key); // don't use move for int type
        }

        return result;
    }
};
#+END_SRC

** Improved
We can use minHeap instead
When heap size() > k, we pop the minimal. It can optimize the size of memory.

#+BEGIN_SRC cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        std::unordered_map<int, int> freqCount;
        for (const auto &i : nums) {
            freqCount[i]++;
        }

        auto cmp = [](const std::pair<int, int> &a,
                      const std::pair<int, int> &b) {
            return a.second > b.second; // change to minHeap
        };
        std::priority_queue<std::pair<int, int>,
                    std::vector<std::pair<int, int>>,
                    decltype(cmp)> minHeap(cmp);

        for (auto &pair : freqCount) {
            minHeap.push(pair);
            if (minHeap.size() > k) {
                minHeap.pop(); // pop the minimal
            }
        }

        vector<int> result;
        while (!minHeap.empty()) {
            result.push_back(minHeap.top().first);
            minHeap.pop();
        }

        return result;
    }
};
#+END_SRC