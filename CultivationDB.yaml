# =============================================================================
# LeetCode Hero - Cultivation Progress Database
# =============================================================================
# This database tracks your mastery level and progress on LeetCode problems
# for technical interview preparation, particularly focused on Google-style
# algorithmic challenges.
#
# STATUS DEFINITIONS:
# -------------------
# L1_FORGOT    (忘) - Problem completely forgotten, requires re-learning from scratch
# L2_STRUGGLE  (解) - Can solve but with difficulty, not interview-ready yet
# L3_MASTERED  (定) - Can solve within 20 minutes, bug-free, handling all edge cases
#
# FIELD DESCRIPTIONS:
# -------------------
# id:                  LeetCode problem number
# title:               Official problem title from LeetCode
# link:                Relative path to your solution folder
# leetcode-difficulty: Official difficulty (easy/medium/hard)
# topics:              Algorithm/data structure tags for categorization
# status:              Your current mastery level (L1_FORGOT/L2_STRUGGLE/L3_MASTERED)
# refinement_focus:    Specific areas to improve or key insights to remember
#
# TOPIC TAGS:
# -----------
# Common tags include: hashtable, hashset, array, linked-list, stack, queue,
# binary-search, two-pointer, sliding-window, dp, backtracking, graph, tree,
# sorting, string, math, greedy, neetcode150
#
# ENTRY TEMPLATE:
# ---------------
#  - id:
#    title: ""
#    link: "./"
#    leetcode-difficulty:
#    topics:
#    status:
#    refinement_focus: ""
#
# =============================================================================

problems:
  - id: 1
    title: "Two Sum"
    link: ./001_Two_Sum/
    leetcode-difficulty: easy
    topics: [hashtable, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Try to use single pass solution"

  - id: 2
    title: "Add Two Numbers"
    link: "./002_Add_Two_Numbers"
    leetcode-difficulty: medium
    topics: [linked-list, indirect-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Try 1: Indirect-pointer and sum/carry handling

      Try 2: Sum/carry is correctly handled, but indirect pointer usage is incorrect. The resultHead and indirect-pointer declarations are poorly structured. Also, (*indirect) = new ListNode(val); is unclear. I incorrectly wrote indirect = &(new ListNode());

  - id: 3
    title: "Longest Substring Without Repeating Characters"
    link: "./003_Longest_Substring_Without_Repeating_Characters"
    leetcode-difficulty: medium
    topics: [hashtable, sliding-window, string, neetcode150]
    status: L3_MASTERED
    refinement_focus: "通常這種題目 While 的使用是關鍵"

  - id: 5
    title: "Longest Palindromic Substring"
    link: "./005_Longest_Palindromic_Substring"
    leetcode-difficulty: medium
    topics: [iteration, dp, manachers-algorithm, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Expand, DP, or Manacher's algorithm"

  - id: 6
    title: "Zigzag Conversion"
    link: "./006_Zigzag_Conversion"
    leetcode-difficulty: medium
    topics: [vector, string]
    status: L3_MASTERED
    refinement_focus: "Updown traverse and push to vector"

  - id: 7
    title: "Reverse Integer"
    link: "./007_Reverse_Integer"
    leetcode-difficulty: medium
    topics: [integer, signed, boundary]
    status: L2_STRUGGLE
    refinement_focus: "The key is boundary + minus"

  - id: 8
    title: "String to Integer"
    link: "./008_String_to_Integer"
    leetcode-difficulty: medium
    topics: [parsing, stoi, boundary, signed, overflow]
    status: L3_MASTERED
    refinement_focus: "boundary + minus"

  - id: 9
    title: "Palindrome Number"
    link: "./009_Palindrome_Number"
    leetcode-difficulty: easy
    topics: [iteration]
    status: L3_MASTERED
    refinement_focus: "std::to_string while"

  - id: 11
    title: "Container With Most Water"
    link: "./011_Container_With_Most_Water"
    leetcode-difficulty: medium
    topics: [two-pointer, array, greedy, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "find the smallest of the two sides, and move the pointer"

  - id: 12
    title: "Integer to Roman"
    link: "./012_Integer_to_Roman"
    leetcode-difficulty: medium
    topics: [array]
    status: L2_STRUGGLE
    refinement_focus: "Transform roman to (value, string) pair and decode greedy"

  - id: 13
    title: "Roman to Integer"
    link: "./013 Roman to Integer"
    leetcode-difficulty: easy
    topics: [array]
    status: L2_STRUGGLE
    refinement_focus: "Need to peek next, to know current is + or -"

  - id: 14
    title: "Longest Common Prefix"
    link: "./014_Longest_Common_Prefix"
    leetcode-difficulty: easy
    topics: [array]
    status: L3_MASTERED
    refinement_focus: "The clean solution is to take the first string as golden"

  - id: 15
    title: "3 Sum"
    link: "./015_3Sum"
    leetcode-difficulty: medium
    topics: [two-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Dupicates handling is tricky"

  - id: 16
    title: "3 Sum Closest"
    link: "./016_3Sum_Closest"
    leetcode-difficulty: medium
    topics: [two-pointer, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "Same as 015_3Sum, but need to track closest value"

  - id: 17
    title: "Letter Combinations of a Phone Number"
    link: "./017_Letter_Combinations_of_a_Phone_Number"
    leetcode-difficulty: medium
    topics: [hashtable, backtracking, string]
    status: L3_MASTERED
    refinement_focus: "Write a good helper pure function"

  - id: 18
    title: "4 Sum"
    link: "./018_4Sum"
    leetcode-difficulty: medium
    topics: [k-sum, two-pointer, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "generalizing k-sum function"

  - id: 19
    title: "Remove Nth Node From End of List"
    link: "./019_Remove_Nth_Node_From_End_of_List"
    leetcode-difficulty: medium
    topics: [fast-and-slow-pointer, linked-list, indirect-pointer, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Indirect-pointer and fast/slow pointer"

  - id: 20
    title: "Valid Parentheses"
    link: "./020_Valid_Parentheses"
    leetcode-difficulty: easy
    topics: [stack, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "I know the stack solution, but I cannot execute it fluently and elegantly"

  - id: 24
    title: "Swap Nodes in Pairs"
    link: "./024_Swap_Nodes_in_Pairs"
    leetcode-difficulty: medium
    topics: [linked-list, indirect-pointer, recursion]
    status: L2_STRUGGLE
    refinement_focus: "While loop or helper recursion"

  - id: 34
    title: "Find First and Last Position of Element in Sorted Array"
    link: "./034_Find_First_and_Last_Position_of_Element_in_Sorted_Array"
    leetcode-difficulty: medium
    topics: [binary-search, array, sorting]
    status: L2_STRUGGLE
    refinement_focus: "lower_bound and upper_bound"

  - id: 35
    title: "Search Insert Position"
    link: "./035_Search_Insert_Position"
    leetcode-difficulty: easy
    topics: [binary-search, array, sorting]
    status: L3_MASTERED
    refinement_focus: "lower_bound"

  - id: 36
    title: "Valid Sudoku"
    link: "./036_Valid_Sudoku"
    leetcode-difficulty: medium
    topics: [hashset, matrix, simulation, neetcode150]
    status: L3_MASTERED
    refinement_focus: "HashSet"

  - id: 42
    title: "Trapping Rain Water"
    link: "./042_Trapping_Rain_Water"
    leetcode-difficulty: hard
    topics: [two-pointer, monotonic-stack, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "next-greater-element or two-pointer"

  - id: 48
    title: "Rotate Image"
    link: "./048_Rotate_Image"
    leetcode-difficulty: medium
    topics: [matrix]
    status: L3_MASTERED
    refinement_focus: "Transpose + Reverse"

  - id: 49
    title: "Group Anagrams"
    link: "./049_Group_Anagrams"
    leetcode-difficulty: medium
    topics: [hashtable, string, sorting, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Sorting"

  - id: 53
    title: "Maximum Subarray"
    link: "./053_Maximum_Subarray"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150, kadane-algorithm]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: One shot Kadane's algorithm after praticing LeetCode #152.

  - id: 56
    title: "Merge Intervals"
    link: "./056_Merge_Intervals"
    leetcode-difficulty: medium
    topics: [array, sorting, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Sorting + Iterate and Merge"

  - id: 61
    title: "Rotate List"
    link: "./061_Rotate_List"
    leetcode-difficulty: medium
    topics: [linked-list, two-pointer, indirect-pointer]
    status: L3_MASTERED
    refinement_focus: "Make the list circular first. There are optimiazations like if k == length, do nothing"

  - id: 70
    title: "Climbing Stairs"
    link: "./070_Climbing_Stairs"
    leetcode-difficulty: easy
    topics: [dp, math, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Fibonacci, bottom-up DP, top-down DP, or even math"

  - id: 91
    title: "Decode Ways"
    link: "./091_Decode_Ways"
    leetcode-difficulty: medium
    topics: [dp, string, backtracking, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means ways to decode s[0..i-1]. Also, we need to handle 1 digit and 2 digit separately"

  - id: 96
    title: "Unique Binary Search Trees"
    link: "./096_Unique_Binary_Search_Trees"
    leetcode-difficulty: medium
    topics: [dp, math, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[n] means number of unique BST that can be built with n nodes. dp[n] = sum of dp[i-1]*dp[n-i] for i in [1..n]. Catalan number"

  - id: 100
    title: "Same Tree"
    link: "./100_Same_Tree"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion"

  - id: 110
    title: "Balanced Binary Tree"
    link: "./110_Balanced_Binary_Tree"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Reviewed the definition of balanced biniary tree. Implementation is smooth, but I forgot to (add 1) when calculating height.

  - id: 104
    title: "Maximum Depth of Binary Tree"
    link: "./104_Maximum_Depth_of_Binary_Tree"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Basic DP"

  - id: 125
    title: "Valid Palindrome"
    link: "./125_Valid_Palindrome"
    leetcode-difficulty: easy
    topics: [two-pointer, string, neetcode150]
    status: L3_MASTERED
    refinement_focus: "isalnum() and tolower()"

  - id: 128
    title: "Longest Consecutive Sequence"
    link: "./128_Longest_Consecutive_Sequence"
    leetcode-difficulty: medium
    topics: [hashset, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "sort is O(n log n), use HashSet to achieve O(n). Check only sequence starters"

  - id: 139
    title: "Word Break"
    link: "./139_Word_Break"
    leetcode-difficulty: medium
    topics: [dp, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Not absolutely sure I can get this right during interview, but I know the idea. ip[i] means s[i..end] can be segmented. Need a helper function isPrefix and a recursive function with memo"

  - id: 146
    title: "LRU Cache"
    link: "./146_LRU_Cache"
    leetcode-difficulty: medium
    topics: [design, linked-list, hashtable, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Always practice. Use std::list + std::unordered_map. please understand why use list"

  - id: 150
    title: "Evaluate Reverse Polish Notation"
    link: "./150_Evaluate_Reverse_Polish_Notation"
    leetcode-difficulty: medium
    topics: [stack, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Edge case are tricky, but the idea is straightforward. Alwasy think when the input is invalid"

  - id: 152
    title: "Maximum Product Subarray"
    link: "./152_Maximum_Product_Subarray"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150, kadane-algorithm]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: The dp logic is not straightforward. The key is the remember three conditions: positve, negative, zero. Using DP to find max positive and min negative

      Attempt 2: The dp logic is smooth. The problem is the initial value of globalMax, localMax, and localMin, I didn't init it to nums[0] in the first place can cause overflow. After fixing, I use ranged based for, so index 0 is calculated twice which is not acceptable.

  - id: 155
    title: "Min Stack"
    link: "./155_Min_Stack"
    leetcode-difficulty: medium
    topics: [stack, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: Don't understand the problem

      Attempt 2: I know the key is to maintain two stacks, and I think through the logic, and slowly implement the code correctly. But cannot do it in a flash.

  - id: 167
    title: "Two Sum II - Input Array Is Sorted"
    link: "./167_Two_Sum_II_Input_Array_Is_Sorted"
    leetcode-difficulty: easy
    topics: [two-pointer, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "trivial two-pointer"

  - id: 198
    title: "House Robber"
    link: "./198_House_Robber"
    leetcode-difficulty: medium
    topics: [dp, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means max amount can be robbed from house[0..i]. dp[i] = max(dp[i-1], dp[i-2]+nums[i]). Use foldl to optimize space"

  - id: 207
    title: "Course Schedule"
    link: "./207_Course_Schedule"
    leetcode-difficulty: medium
    topics: [graph, bfs, dfs, topological-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      BFS or DFS coloring to detect cycle. Or use Kahn's algorithm to do topological sort.

      2nd time re-learn. I use enum-class to define colors. And get it almost right

  - id: 210
    title: "Course Schedule II"
    link: "./210_Course_Schedule_II"
    leetcode-difficulty: medium
    topics: [graph, bfs, dfs, topological-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      First time, now forget how to trace the path

      Second time re-learn. Khan's algorithm is easy to implement. The error I made is indeg[course] == 0, I wrote indeg[course] != 0.

  - id: 211
    title: "Design Add and Search Words Data Structure"
    link: "./211_Design_Add_and_Search_Words_Data_Structure"
    leetcode-difficulty: medium
    topics: [trie, backtracking, design, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      When doing rirst time seeing Trie, need to re-learn. The key is the struct (data)

      Second time re-learn, I found myself forgetting the important details, like using `std::unique_ptr`. Also, rememeber to use `auto it = map.emplace(...).first`. Emplace returns a pair<iterator, bool>. We can add (void) infront of emplace if we don't care about the return value.

  - id: 213
    title: "House Robber II"
    link: "./213_House_Robber_II"
    leetcode-difficulty: medium
    topics: [dp, circular, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Arranged in circle. Two cases: rob house[0..n-2] or house[1..n-1]"

  - id: 217
    title: "Contains Duplicate"
    link: "./217_Contains_Duplicate"
    leetcode-difficulty: easy
    topics: [hashset, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "HashSet"

  - id: 226
    title: "Invert Binary Tree"
    link: "./226_Invert_Binary_Tree"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion or Iteration"

  - id: 238
    title: "Product of Array Except Self"
    link: "./238_Product_of_Array_Except_Self"
    leetcode-difficulty: medium
    topics: [array, prefix-sum, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Prefix and Suffix product arrays, or use output array as prefix product array to save space"

  - id: 239
    title: "Sliding Window Maximum"
    link: "./239_Sliding_Window_Maximum"
    leetcode-difficulty: hard
    topics: [monotonic-queue, array, sliding-window, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: WTF
      Attempt 2: I can quickly write the whole solution. But there are 2 problems. First, indices are wrong. Second, I caused overflow by not checking (idx >= k) when calculating std::size_t. Be extra cautious when using unsigned types.

  - id: 278
    title: "First Bad Version"
    link: "./278_First_Bad_Version"
    leetcode-difficulty: easy
    topics: [binary-search, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Just standard [start, end) binary search to change the predicate"

  - id: 300
    title: "Longest Increasing Subsequence"
    link: "./300_Longest_Increasing_Subsequence"
    leetcode-difficulty: medium
    topics: [dp, binary-search, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "DP O(n^2) or Binary Search O(n log n). Binary search is never practiced. dp[i] means from nums[0..i], the longest increasing subsequence that ends with nums[i]"

  - id: 310
    title: "Minimum Height Trees"
    link: "./310_Minimum_Height_Trees"
    leetcode-difficulty: medium
    topics: [graph, bfs, tree, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Peel off the leaves layer by layer until 1 or 2 nodes left"

  - id: 322
    title: "Coin Change"
    link: "./322_Coin_Change"
    leetcode-difficulty: medium
    topics: [dp, bfs, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "dp[i] means the minimum coins to make amount i"

  - id: 347
    title: "Top K Frequent Elements"
    link: "./347_Top_K_Frequent_Elements"
    leetcode-difficulty: medium
    topics: [hashtable, heap, bucket-sort, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Use HashMap to count frequency, then use Min-Heap or Bucket Sort to get top K. Bucket sort is optimal O(n), but I forget how to implement it"

  - id: 416
    title: "Partition Equal Subset Sum"
    link: "./416_Partition_Equal_Subset_Sum"
    leetcode-difficulty: medium
    topics: [dp, knapsack, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: |
      Attempt 1: The first time I need to learn from the answer and learn knapsack. dp[i][j] means using nums[0..i], can we fill a knapsack of capacity j. dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]"

      Attempt 2: Fast implement. Forget to set dp[0] = true. Forget std::accumulate need to add accumulator 0 and include numeric. Should be L2~L3. But I set to L2. Lets practice later.

  - id: 496
    title: "Next Greater Element I"
    link: "./496_Next_Greater_Element_I"
    leetcode-difficulty: easy
    topics: [monotonic-stack, hashtable, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Monotonic stack."

  - id: 503
    title: "Next Greater Element II"
    link: "./503_Next_Greater_Element_II"
    leetcode-difficulty: medium
    topics: [monotonic-stack, array, circular, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Monotonic stack. Circular array can be simulated by iterating 2 times"

  - id: 509
    title: "Fibonacci Number"
    link: "./509_Fibonacci_Number"
    leetcode-difficulty: easy
    topics: [dp, recursion, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion with memo or bottom-up DP"

  - id: 543
    title: "Diameter of Binary Tree"
    link: "./543_Diameter_of_Binary_Tree"
    leetcode-difficulty: easy
    topics: [tree, bfs, binary-tree, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Recursion or FOLD"

  - id: 572
    title: "Subtree of Another Tree"
    link: "./572_Subtree_of_Another_Tree"
    leetcode-difficulty: easy
    topics: [tree, dfs, bfs, neetcode150]
    status: L3_MASTERED
    refinement_focus: |
      Attempt 1: Recusive and helper is same funciton can solve the problem. But I think what if we can use KMF algorithm way like structure?

  - id: 647
    title: "Palindromic Substrings"
    link: "./647_Palindromic_Substrings"
    leetcode-difficulty: medium
    topics: [dp, string, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Very similar to 005_Longest_Palindromic_Substring. There are three ways: Expand, 2D-dp, or 1D-dp build up layer by layer"

  - id: 704
    title: "Binary Search"
    link: "./704_Binary_Search"
    leetcode-difficulty: easy
    topics: [binary-search, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "Standard binary search template"

  - id: 746
    title: "Min Cost Climbing Stairs"
    link: "./746_Min_Cost_Climbing_Stairs"
    leetcode-difficulty: easy
    topics: [dp, array, neetcode150]
    status: L3_MASTERED
    refinement_focus: "dp[i] means min cost to reach step i. dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])"

  - id: 852
    title: "Peak Index in a Mountain Array"
    link: "./852_Peak_Index_in_a_Mountain_Array"
    leetcode-difficulty: easy
    topics: [binary-search, array, neetcode150]
    status: L2_STRUGGLE
    refinement_focus: "Binary search to find the first location where arr[i] > arr[i+1]"